#!/usr/bin/env python3
#
# Polymero
#

#-------------------------------------------------------------
# SOLVE SCRIPT FOR "URSA MINOR"
#-------------------------------------------------------------

# Imports
from sage.all import *
from pwn import *
from hashlib import sha256

# Connection
host = '0.0.0.0'
port = '5000'

# context.log_level = 'debug'


# OFFLINE PARAMETER
seed_fix_10 = '101780904466fe3e93f9205c51d2064bb9061298226d81235b35fe7769195500'


# Functions
def oracle_encrypt(s, x):
	''' Use the connection to the oracle 's' to return the encryption of 'x'. '''
	s.sendline(b"e")
	s.recv()
	s.sendline(''.join([hex(i)[2:] for i in x]).encode())
	s.recvuntil(b'~ ')
	y = [int(i,16) for i in s.recvuntil(b"\n", drop=True).decode()]
	s.recv()
	return y

def ret_max_count(x: list) -> list:
	''' Return only the most occuring elements of 'x'. '''
    uniq = list(set(x))
    cnts = [sum(int(i == j) for j in x) for i in uniq]
    mx = max(cnts)
    return [uniq[i] for i in range(len(uniq)) if cnts[i] == mx]


# Script
REC = 1
while REC:

	# Connect
	s = connect(host, port)

	print(REC, end='\r', flush=True)
	REC += 1

	# Get encrypted flag
	s.recvuntil(b"flag = ")
	encflag = bytes.fromhex(s.recvuntil(b"\n", drop=True).decode())

	# Send our seed
	s.recv()
	s.sendline(seed_fix_10.encode())

	# Get s-box
	s.recvuntil(b"s-box = ")
	sbox = eval(s.recvuntil(b"\n", drop=True).decode())
	assert sum(i == j for i,j in enumerate(sbox)) == 10

	# Get p-box
	s.recvuntil(b"p-box = ")
	pbox = eval(s.recvuntil(b"\n", drop=True).decode())

	cip_lst = []
	key_mat = []

	for ji in range(16):

		# Get permutations
		js = [ji]
		for _ in range(4):
			js += [pbox.index(js[-1])]

		# Build permutated key matrix
		key_mat += [[1 if j in js else 0 for j in range(16)]]

		# Get most occuring ciphertext elements
		cip_lst += [ret_max_count([oracle_encrypt(s, [0]*ji + [k] + [0]*(16-ji-1))[js[-1]] ^ k for k in range(16)])]

	# Convert key matrix from 4-bit to single bit
	bit_mat = []
	for row in key_mat:
		for i in range(4):
			bit_mat += [[]]
			for j in row:
				bit_mat[-1] += [0]*i + [j] + [0]*(3 - i)

	# Make sure it is solvable
	if Matrix(GF(2), bit_mat).rank() == 64:

		for _ in range(100):

			# Convert randomly sampled ciphertext from 4-bit to single bit
			cip_vec = [sample(i, 1)[0] for i in cip_lst]
			bit_vec = [m for n in [[int(i) for i in '{:04b}'.format(j)] for j in cip_vec] for m in n]

			# Solve 'Ax = y' for 'x'
			key_vec = Matrix(GF(2), bit_mat).solve_right(Matrix(GF(2), bit_vec).T)
			key_lst = key_vec.list()
			key_rec = [int(''.join(str(j) for j in key_lst[i:i+4]), 2) for i in range(0, len(key_lst), 4)]

			# Derive OTP key from recovered key vector
			otp = b""
			while len(otp) < len(encflag):
				otp += sha256(b" :: ".join([b"OTP", str(key_rec).encode(), len(otp).to_bytes(2, 'big')])).digest()

			# Recover the flag
			rec_flag = bytes([i ^ j for i,j in zip(encflag, otp)])

			if b"flag" in rec_flag:
				print(REC, rec_flag)
				REC = 0
				break

	s.close()



