#!/usr/bin/env python3
#
# Polymero
#

# Imports
from pwn import *
from secrets import randbelow
from hashlib import sha256
import os, time

# Globals
SEQ_LIMIT = 6


#+-------------------------+
#|   CLASSES & FUNCTIONS   |
#+-------------------------+
# Connection class
class ORACLE:
    def __init__(self, s):
        self.s = s
        
    @staticmethod
    def remote(host, port, debug=False):
        if debug:
            context.log_level = 'debug'
        return ORACLE(connect(host, port))
        
    @staticmethod
    def local(file, proc='python3'):
        return ORACLE(process([proc, file]))
        
    def parse(self, seed):
        # Get flag
        self.s.recvuntil(b"flag = ")
        self.flag = bytes.fromhex(self.s.recvuntil(b"\n", drop=True).decode())
        # Send seed
        self.s.recv()
        self.s.sendline(seed.encode())
        # Get sbox
        self.s.recvuntil(b"s-box = ")
        self.sbox = eval(self.s.recvuntil(b"\n", drop=True).decode())
        # Get pbox
        self.s.recvuntil(b"p-box = ")
        self.pbox = eval(self.s.recvuntil(b"\n", drop=True).decode())
        
    def encrypt(self, pt):
        self.s.sendline(b"e")
        self.s.recv()
        self.s.sendline(''.join([hex(i)[2:] for i in pt]).encode())
        self.s.recvuntil(b"~ ")
        ct = [int(i, 16) for i in self.s.recvuntil(b"\n", drop=True).decode()]
        self.s.recv()
        return ct

    def exit(self):
        self.s.close()


# Functions
def pbox_seqs(pbox):
    ''' Returns max sequence size and list of sequences for a given pbox. '''
    j = []
    for j_start in range(16):
        j += [[j_start]]
        while True:
            k = pbox.index(j[-1][-1])
            if k == j_start:
                break
            j[-1] += [k]
    return max(len(i) for i in j), j


#-------------+
#|   ATTACK   |
#-------------+
print('+----------------------------------------+')
print('|   SOLVE SCRIPT :: Nothing Up My Sbox   |')
print('+----------------------------------------+')
print('|\n|  ~ Looking for a sufficiently weak pbox ::')

CONNS = 0
while True:
    CONNS += 1

    # Use 'remote' or 'local' method
    oracle = ORACLE.local('nothingupmysbox.py')
    
    # Give whatever seed
    oracle.parse('Polymero')

    # Check sequences
    max_s, SEQS = pbox_seqs(oracle.pbox)
    if max_s < SEQ_LIMIT:
        break

    print('|    Attempt {} yielded max sequence of {}'.format(CONNS, max_s))

    oracle.exit()

print('|\n|  ~ Divide-and-Conquer attack on ORACLE with ::')
print('|    sbox = {}'.format(oracle.sbox))
print('|    pbox = {}'.format(oracle.pbox))

# Cipher parameters
BLOCK_SIZE = 64 
ELEM_SIZE  = 4 
ELEM_NUM   = BLOCK_SIZE // ELEM_SIZE
ELEM_MOD   = 2 ** ELEM_SIZE
NUM_ROUNDS = 4

# Find all unique sequences
UNIQS = []
res = list(range(ELEM_MOD))
for i in SEQS:
    if i[0] in res:
        UNIQS += [i]
        for j in i:
            res.remove(j)

REC_KEY = [0] * ELEM_NUM
POS_KEY = [[] for _ in UNIQS]

print('|\n|  ~ Found unique sequences ::')
for i in UNIQS:
    print('|    {}'.format(i))

# Divide-and-Conquer
T0    = time.time()
CALLS = 0
while not all(len(i) == 1 for i in POS_KEY):
    CALLS += 1
    
    # Get plaintext ciphertext pair
    plaintext  = [randbelow(ELEM_MOD) for _ in range(ELEM_NUM)]
    ciphertext = oracle.encrypt(plaintext)
    
    print('|\n|  ~ ({}s) Encryption call {} ::'.format(int(time.time() - T0), CALLS))
    print('|    pt = {}'.format(plaintext))
    print('|    ct = {}'.format(ciphertext))
    print('|')
    
    for n,seq in enumerate(UNIQS):
        
        if len(POS_KEY[n]) == 1:
            continue
            
        print('|    {} ->'.format(seq), end='\r', flush=True)
    
        start  = [plaintext[i] for i in seq]
        target = [ciphertext[i] for i in seq]
        
        found_keys = []
        for int_key in range(ELEM_MOD ** len(seq)):
            
            key = []
            while len(key) < len(seq):
                key = [int_key % ELEM_MOD] + key
                int_key //= ELEM_MOD
                
            x = start[:]
            for k in range(NUM_ROUNDS + 1):
                if not k:
                    x = [i ^ j for i,j in zip(x, key)]
                else:
                    x = [oracle.sbox[i] for i in x]
                    x = [x[-1]] + x[:-1]
                    x = [i ^ j for i,j in zip(x, key)]
                    
            if x == target:
                found_keys += [key]
                
        if not POS_KEY[n]:
            POS_KEY[n] = found_keys
        else:
            POS_KEY[n] = [i for i in found_keys if i in POS_KEY[n]]
            
        print('|    {} -> {}'.format(seq, POS_KEY[n]))
        
key_inds = [i for j in UNIQS for i in j]
key_vals = [i for j in POS_KEY for i in j[0]]
for k in range(ELEM_NUM):
    REC_KEY[key_inds[k]] = key_vals[k]
            
print('|\n|  ~ ({}s) Done in {} encryption calls::'.format(int(time.time() - T0), CALLS))
print('|    KEY = {}'.format(REC_KEY))

# Derive OTP key from recovered key vector
otp = b""
while len(otp) < len(oracle.flag):
    otp += sha256(b" :: ".join([b"OTP", str(REC_KEY).encode(), len(otp).to_bytes(2, 'big')])).digest()

# Recover the flag
FLAG = bytes([i ^ j for i,j in zip(oracle.flag, otp)])

print('|\n|  ~ Hey look at this, it looks like I found the flag ::')
print('|    {}'.format(FLAG))
print('|\n|')